# Stubs for django.db.models.query (Python 3.6)
#
# NOTE: This dynamically typed stub was automatically generated by stubgen.

from django.db.models.query_utils import InvalidQuery as InvalidQuery
from django.db.models.query_utils import Q as Q
from typing import Any, Optional

REPR_OUTPUT_SIZE: int
EmptyResultSet: Any

class BaseIterable:
    queryset: Any = ...
    chunked_fetch: Any = ...
    def __init__(self, queryset, chunked_fetch: bool = ...) -> None: ...

class ModelIterable(BaseIterable):
    def __iter__(self): ...

class ValuesIterable(BaseIterable):
    def __iter__(self): ...

class ValuesListIterable(BaseIterable):
    def __iter__(self): ...

class FlatValuesListIterable(BaseIterable):
    def __iter__(self): ...

class QuerySet:
    model: Any = ...
    query: Any = ...
    def __init__(self, model: Optional[Any] = ..., query: Optional[Any] = ..., using: Optional[Any] = ..., hints: Optional[Any] = ...) -> None: ...
    #def as_manager(cls): ...
    as_manager: Any = ...
    def __deepcopy__(self, memo): ...
    def __len__(self): ...
    def __iter__(self): ...
    def __bool__(self): ...
    def __nonzero__(self): ...
    def __getitem__(self, k): ...
    def __and__(self, other): ...
    def __or__(self, other): ...
    def iterator(self): ...
    def aggregate(self, *args, **kwargs): ...
    def count(self): ...
    def get(self, *args, **kwargs): ...
    def create(self, **kwargs): ...
    def bulk_create(self, objs, batch_size: Optional[Any] = ...): ...
    def get_or_create(self, defaults: Optional[Any] = ..., **kwargs): ...
    def update_or_create(self, defaults: Optional[Any] = ..., **kwargs): ...
    def earliest(self, field_name: Optional[Any] = ...): ...
    def latest(self, field_name: Optional[Any] = ...): ...
    def first(self): ...
    def last(self): ...
    def in_bulk(self, id_list: Optional[Any] = ...): ...
    def delete(self): ...
    def update(self, **kwargs): ...
    def exists(self): ...
    def raw(self, raw_query, params: Optional[Any] = ..., translations: Optional[Any] = ..., using: Optional[Any] = ...): ...
    def values(self, *fields, **expressions): ...
    def values_list(self, *fields, **kwargs): ...
    def dates(self, field_name, kind, order: str = ...): ...
    def datetimes(self, field_name, kind, order: str = ..., tzinfo: Optional[Any] = ...): ...
    def none(self): ...
    def all(self): ...
    def filter(self, *args, **kwargs): ...
    def exclude(self, *args, **kwargs): ...
    def complex_filter(self, filter_obj): ...
    def union(self, *other_qs, **kwargs): ...
    def intersection(self, *other_qs): ...
    def difference(self, *other_qs): ...
    def select_for_update(self, nowait: bool = ..., skip_locked: bool = ...): ...
    def select_related(self, *fields): ...
    def prefetch_related(self, *lookups): ...
    def annotate(self, *args, **kwargs): ...
    def order_by(self, *field_names): ...
    def distinct(self, *field_names): ...
    def extra(self, select: Optional[Any] = ..., where: Optional[Any] = ..., params: Optional[Any] = ..., tables: Optional[Any] = ..., order_by: Optional[Any] = ..., select_params: Optional[Any] = ...): ...
    def reverse(self): ...
    def defer(self, *fields): ...
    def only(self, *fields): ...
    def using(self, alias): ...
    @property
    def ordered(self): ...
    @property
    def db(self): ...

class InstanceCheckMeta(type):
    def __instancecheck__(self, instance): ...

class EmptyQuerySet:
    def __init__(self, *args, **kwargs) -> None: ...

class RawQuerySet:
    raw_query: Any = ...
    model: Any = ...
    query: Any = ...
    params: Any = ...
    translations: Any = ...
    def __init__(self, raw_query, model: Optional[Any] = ..., query: Optional[Any] = ..., params: Optional[Any] = ..., translations: Optional[Any] = ..., using: Optional[Any] = ..., hints: Optional[Any] = ...) -> None: ...
    def resolve_model_init_order(self): ...
    def __iter__(self): ...
    def __getitem__(self, k): ...
    @property
    def db(self): ...
    def using(self, alias): ...
    def columns(self): ...
    def model_fields(self): ...

class Prefetch:
    prefetch_through: Any = ...
    prefetch_to: Any = ...
    queryset: Any = ...
    to_attr: Any = ...
    def __init__(self, lookup, queryset: Optional[Any] = ..., to_attr: Optional[Any] = ...) -> None: ...
    def add_prefix(self, prefix): ...
    def get_current_prefetch_to(self, level): ...
    def get_current_to_attr(self, level): ...
    def get_current_queryset(self, level): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

def normalize_prefetch_lookups(lookups, prefix: Optional[Any] = ...): ...
def prefetch_related_objects(model_instances, *related_lookups): ...
def get_prefetcher(instance, through_attr, to_attr): ...
def prefetch_one_level(instances, prefetcher, lookup, level): ...

class RelatedPopulator:
    db: Any = ...
    cols_start: Any = ...
    cols_end: Any = ...
    init_list: Any = ...
    reorder_for_init: Any = ...
    model_cls: Any = ...
    pk_idx: Any = ...
    related_populators: Any = ...
    reverse_cache_name: Any = ...
    cache_name: Any = ...
    def __init__(self, klass_info, select, db) -> None: ...
    def populate(self, row, from_obj): ...

def get_related_populators(klass_info, select, db): ...
